\documentclass[11pt,utf8,notoc,bibnum,german,final]{zihpub}
\usepackage{url}

\title{Escalator}
\author{Hermann Loose}
\matno{3411242}
\betreuer{Jupp Müller}
\bibfiles{report}
\begin{document}

% TODO(hermannloose): Was ist ein gutes Wort dafür?
\section{Related Work}

Gesucht wurde nach einer \emph{flexiblen, quell-offenen}
Benachrichtigungslösung, welche zudem \emph{rotierende Bereitschaftsdienste}
verwaltet und möglichst auch \emph{nur} das tut. Es folgen einige kurz
evaluierte Optionen.

\paragraph{Nagios Benachrichtigungen \cite{nagios-notifications}}

Nagios ermöglicht die Definition von Eskalationsstrategien für
Benachrichtigungen über Konfigurationsdateien. Weitere Recherche förderte für
diese Methode kein zufriedenstellendes Web-Frontend zutage. Das einzige
Resultat in dieser Richtung war NoMa \cite{noma}, welches nicht die gewünschte
Flexibilität im Bezug auf die Verwaltung von Eskalationsstrategien und die
Rotation von Bereitschaftsdiensten zu bieten schien.

Zudem würde sich eine Lösung mittels Nagios gleichzeitig auf Nagios beschränken
und dem Wunsch gegenüber stehen, die Benachrichtigungen verschiedener Dienste
in einem einzelnen System aggregieren zu können.

\paragraph{PagerDuty \cite{pagerduty}}

In San Francisco ansässiges Start-up, dessen Produkt der Verkauf von Anruf- und
SMS-Guthaben rund um ein Benachrichtigungssystem ist, welches den Vorstellungen
für Escalator—ob der relativen Offensichtlichkeit dieser Idee—sehr nahe kommt.
Allerdings fällt hier die fehlende Quelloffenheit ins Gewicht, welche es
unwahrscheinlich macht, das System um die angedachte Android-Integration
erweitern zu können.

Zudem scheint das Routing von Ereignissen aus Monitoringsystemen zu PagerDuty
ausschließlich über Email abzulaufen, was für eine verbesserte Anbindung der
Daten zuführenden Systeme in der Zukunft über eine robuste Schnittstelle—im
Falle von Escalator HTTP nach REST-Prinzipien—ungünstig erscheint.

\paragraph{}

Da sich keine der betrachteten Optionen als im Bezug auf die genannten
Kriterien zufriedenstellend erwies, wurde beschlossen, eine prototypische
Anwendung für eben diesen Zweck selbst zu implementieren.

\section{Konzept}

Eingehende Ereignisse werden in Escalator zunächst jeweils einem von
beliebig vielen, frei definierbaren Zuständigkeitsbereichen zugeordnet. Diese
Unterteilung kann beispielsweise anhand der betroffenen Technologie erfolgen,
wie etwa \emph{Webserver}, \emph{Datenbank}, \emph{Netzwerk}, oder auch
geographisch motiviert sein, wie etwa \emph{Data Center A}, \emph{Data Center
B}, etc.

Innerhalb eines solchen Zuständigkeitsbereichs soll eine einfache Hierarchie
von zu benachrichtigenden Benutzern abgebildet werden, welche im Bezug auf
diesen Bereich \emph{Bereitschaftsdienst} haben. Die erste Ebene des
Bereitschaftsdienstes ist intuitiv über eingehende Ereignisse immer ohne
zeitliche Verzögerung zu benachrichtigen. Erfolgt von Seiten des betroffenen
Benutzers keine Reaktion auf ein Ereignis, wird nach einer für den jeweiligen
Zuständigkeitsbereich definierten Zeitspanne die nächste Ebene des
Bereitschaftsdienstes benachrichtigt.

Auf diesem Weg soll von Escalator als Kernfunktionalität sichergestellt werden,
dass auftretende Ereignisse nie über längere Zeit unbeachtet bleiben, aus
vielfältigen Gründen wie „Diensthandy im Funkloch bzw. aufgrund niedrigen
Akkuladezustands ausgeschaltet“, „Bereitschaftsdienst überhört Diensthandy“,
etc. Darüber hinaus ergeben sich wünschenswerte Features, die teilweise im
Prototyp bereits erprobt wurden.

Erhält ein Bereitschaftsdienst eine Benachrichtigung, die er zwar registriert,
aufgrund der Umstände allerdings aktuell nicht bearbeiten kann, bietet
Escalator im Prototyp—für Android als Plattform des mobilen Endgeräts—bereits
die Möglichkeit, dieses Ereignis sofort manuell zur nächsten Hierarchieebene zu
eskalieren, um die geringstmögliche Verzögerung bis zur tatsächlichen
Behandlung eines Ereignisses zu erreichen.

Ebenfalls prototypisch angelegt ist die automatische, regelmäßige Rotation der
Benutzer, welche sich als Gruppe den Posten eines Bereitschaftsdienstes teilen.
Die vorgesehene Nutzung des Features ist hier z.B. ein wöchentlicher Wechsel
des zuständigen Benutzers. Der konkrete Zeitplan ist für jede einzelne
Hierarchieebene separat konfigurierbar.

Da wahrscheinlich jeder Benutzer eigene Präferenzen für die Art und Weise der
Benachrichtigung haben wird, besitzt der Prototyp bereits die Möglichkeit, für
jede Mitgliedschaft in einer solchen Gruppe einzeln festzulegen, in welchen
Zeitabständen er über welche Wege benachrichtigt werden soll. Erfolgt so z.B.
auf eine unmittelbar nach Zuteilung eines Ereignisses versandte SMS nicht
innerhalb von drei Minuten eine Reaktion, versendet Escalator eine Email, bzw.
es wird ein automatischer Anruf getätigt etc.

Auf diesem Weg kann der zuständige Benutzer auch bei Ausfall oder
Nichtbeachtung eines Benachrichtungsweges zuverlässig—sofern er diese Schritte
sinnvoll gewählt hat—erreicht werden, ohne dass im Normalfall zuviele
gleichzeitige Benachrichtigungen über zuviele verschiedene Kanäle für eine
Abstumpfung gegenüber diesen Signalen sorgen. Ebenso ist eine intuitive
Abgrenzung von Zuständigkeitsbereichen anhand des Benachrichtigungsweges für
ein Ereignis möglich, falls der Benutzer mehrere Bereitschaftsdienste
gleichzeitig erfüllen sollte und dies wünscht.

% FIXME(hermannloose): Eventuell weiter unten als "Ausblick"?

Geplant ist weiterhin die Möglichkeit der flexiblen Definition von
Urlaubszeiträumen, Krankschreibungen etc. für jeden Benutzer, sodass von
Escalator in dieser Zeit andere Benutzer ersatzweise zum Bereitschaftsdienst
eingeteilt werden können. Idealerweise sollte diese Möglichkeit zu einem hohen
Grad in der Hand der betroffenen Benutzer liegen, um eine zusätzliche
Arbeitsbelastung von Benutzern mit administrativer Rolle gering zu halten. Dies
würde auch spontanen Diensttausch unter Benutzern unbürokratisch gestalten.

\section{Implementierung}

\subsection{Web-Schnittstelle und Backend}

Für die Implementierung der Web-Schnittstelle und des Backends wurde das
Webframework Rails \cite{rails} ausgewählt, da ich bereits mit der Sprache
Ruby vertraut war, um Rails als praxiserprobtes Framework herum ein sehr
fortgeschrittenes Ökosystem von Erweiterungen existiert und die Ruby on Rails
Guides \cite{rails-guides} sehr viel unterstützendes Material für Anfänger
bereit stellen.

Aufgrund seiner Ausrichtung auf den REST-Architekturstil \cite{fielding-rest}
eignet sich Rails dazu, sowohl das Web-Frontend für die Verwaltung von
Eskalationsstrategien, Rotationen, Benutzern etc. als auch die API für die
Anbindung von Drittsystemen, welche Ereignisse liefern, in einer einzigen
Anwendung zu vereinen. Codegenerierung mittels \emph{Scaffolding} ermöglichte
hier einen sehr schnellen Start bei der Anlage grundlegender Strukturen der
Datenhaltung und von Formularen zur Manipulation von diesen.

% TODO(hermannloose): Left off here.

Während der Entwicklung des Prototyps habe ich mich neben der eigentlichen
Programmierung mit einigen \emph{Best Practices} der Rails-Entwicklung befasst.
So erfolgte nach der anfänglichen Verwendung des in Ruby selbst enthaltenen
Testframeworks \emph{Test::Unit} \cite{testunit}—bei der Neuanlage von
Rails-Anwendungen ohne weitere Parameter standardmäßig ausgewählt—nach kurzer
Zeit der Wechsel zum mittlerweile Quasi-Standard der Rails-Welt in dieser
Hinsicht, \emph{RSpec} \cite{rspec}.

Für die asynchrone Abarbeitung von im Hintergrund laufenden
Tasks—beispielsweise die rechtzeitige Eskalation von Ereignisse nach Ablauf
einer Zeitspanne—wurde die für diese Zwecke populäre Erweiterung
\emph{delayed\_job} \cite{delayedjob} eingesetzt. Diese hat den Vorteil, dass
die Jobverwaltung komplett über die bereits von Rails verwendete Datenbank
abgewickelt werden kann und die Einstiegshürde sehr gering ist.

Da es sich bei Escalator weniger um einen Wegwerf-Prototypen als vielmehr um
Entwicklung nach dem Prinzip von \emph{Tracer Bullets} \cite{tracerbullets}
handeln soll, wurden Authentifizierung und Authorisierung innerhalb der
Anwendung ebenfalls beleuchtet, um auch unter diesen Gesichtspunkten zu planen.
Die Authentifizierung erfolgt mittels \emph{Devise} \cite{devise}, die
Authorisierung auf Ressourcenebene rollenbasiert via
\emph{declarative\_authorization} \cite{declarative-authorization}, beides
ebenfalls sehr populäre Lösungen in Form von Rails-Erweiterungen.

\subsection{Android-App}

\section{Ausblick}

\end{document}
